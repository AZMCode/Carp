(Debug.sanitize-addresses)
(Project.config "print-ast" true)

;; Preventing the usage of a reference to a deleted object
;; (defn f []
;;   (let-do [x @"DATA"
;;            r &x]
;;     (delete x)
;;     (IO.println r)))

;; Same as above, but deleting the argument
;; (defn g [x]
;;   (let-do [r &x]
;;     (delete (the String x))
;;     (IO.println r)))

(defn dangling []
  (let [b [1 2 3]]
    &b))

;; Lambdas
;; (defn l []
;;   (let [x @"DATA"
;;         r &x
;;         f (fn [] (IO.println r))]
;;     (do
;;       (String.delete x)
;;       (f))))

;; (defn from-ptr [a]
;;   (if (null? a)
;;     (Maybe.Nothing)
;;     (Maybe.Just @(Pointer.to-ref a))))

;; (defn pair-eq [p1 p2]
;;   (and (= (Pair.a p1) (Pair.a p2))
;;        (= (Pair.b p1) (Pair.b p2)))
;;   )

;; (defn map-put []
;;   (fn [b]
;;     (let [n &b]
;;       ())))


;; (defn f [x y]
;;   (let [s @"hej"
;;         z 123]
;;     (Int.+ x y)))



;; (defn f []
;;   &100) ;; TODO: Number literals should create prim var deleter too!



;; use-ref-in-lambda-after-free
;; (defn boo []
;;   (let-do [data @"DATA"
;;            r &data
;;            f (fn []
;;                (IO.println (id r)))]
;;     ;;(String.delete data)
;;     (f)))



;; (defn foo []
;;   (let-do [data [10 20 30]
;;            r &data
;;            f (fn [] (Array.nth r 1))]
;;     ;;(Array.delete data)
;;     (println* (f))))

;; (defn lam []
;;   (let [stuff [100 200 300]
;;         ;;r &stuff
;;         f (fn []
;;             (println* (id &stuff)))]
;;     (f)))



;; Problematic order of arguments, the variable 'b' will depend on 'snake', which is consumed first in the call to Snake.set-body
;; (use Array)
;; (deftype Snake [body (Array Int)])

;; (defn grow [snake]
;;   (let [b (Snake.body &snake)]
;;     (Snake.set-body snake (push-back @b 0))))

;;(unsafe-last b)
