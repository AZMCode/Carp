(Debug.sanitize-addresses)
(Project.config "print-ast" true)

;; ;; Preventing the usage of a reference to a deleted object
;; (defn f []
;;   (let-do [x @"DATA"
;;            r &x]
;;     (delete x)
;;     (IO.println r)))

;; Same as above, but deleting the argument
;; (defn g [x]
;;   (let-do [r &x]
;;     (delete (the String x))
;;     (IO.println r)))

;; A function that takes refs as arguments
;; (defn h [r]
;;   (IO.println r))

(macro-log "")
(macro-log "--------------------------------------------------------------------------------------------------")
(macro-log "")

;; (defn o []
;;   (let [b [1 2 3]
;;         r &b]
;;     @r))

;; (defn p []
;;   (let [b [@"DATA"]
;;         r &b
;;         n (Array.nth r 0)]
;;     @n))

;; ;; More 'nth'
;; (defn m []
;;   (let [b [@"MORE" @"DATA"]
;;         n (Array.nth &b 0)]
;;     @n))

;; Lambdas
;; (defn l []
;;   (let [x @"DATA"
;;         r &x
;;         f (fn [] (IO.println r))]
;;     (do
;;       (String.delete x)
;;       (f))))

;; (defn from-ptr [a]
;;   (if (null? a)
;;     (Maybe.Nothing)
;;     (Maybe.Just @(Pointer.to-ref a))))


;; (defn w []
;;   (let [a [1 2 3]
;;         r &a]
;;     (do
;;       ;;(Array.delete a)
;;       (IO.println &(str
;;                     (Array.nth
;;                      r
;;                      0))))))

;; (defn pair-eq [p1 p2]
;;   (and (= (Pair.a p1) (Pair.a p2))
;;        (= (Pair.b p1) (Pair.b p2)))
;;   )

;; (defn map-put []
;;   (fn [b]
;;     (let [n &b]
;;       ())))


;; (defn f [x y]
;;   (let [s @"hej"
;;         z 123]
;;     (Int.+ x y)))

;; (defn f []
;;   &100) ;; TODO: Number literals should create prim var deleter too!



;; (use Map)
;; (use Bucket)

;; (defn put [k v]
;;   (fn [b]
;;     (let [n (Array.nth &b 0)
;;           new-b (Bucket.put @n k v)]
;;       (Array.aset b 0 new-b))))

;; (defn f []
;;   (let [stuff [100 200 300]]
;;     (fn [] (copy (Array.nth &stuff 0)))))

;; (defn g []
;;   (let [stuff [1 2 3]
;;         r &stuff
;;         f (fn [] r)]
;;     (do (Array.delete stuff)
;;         (f))))


;; use-ref-in-lambda-after-free
;; (defn boo []
;;   (let-do [data @"DATA"
;;            r &data
;;            f (fn []
;;                (IO.println (id r)))]
;;     ;;(String.delete data)
;;     (f)))



;; (defn foo []
;;   (let-do [data [10 20 30]
;;            r &data
;;            f (fn [] (Array.nth r 1))]
;;     ;;(Array.delete data)
;;     (println* (f))))

;; (defn lam []
;;   (let [stuff [100 200 300]
;;         ;;r &stuff
;;         f (fn []
;;             (println* (id &stuff)))]
;;     (f)))


;; Add test for this!!!
;; (defn invalid-use [xs]
;;   (let [r &xs]
;;     (do (delete xs)
;;         r)))



;; Problematic order of arguments, the variable 'b' will depend on 'snake', which is consumed first in the call to Snake.set-body
;; (use Array)
;; (deftype Snake [body (Array Int)])

;; (defn grow [snake]
;;   (let [b (Snake.body &snake)]
;;     (Snake.set-body snake (push-back @b 0))))

;;(unsafe-last b)
