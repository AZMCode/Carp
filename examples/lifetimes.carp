(Debug.sanitize-addresses)
(Project.config "print-ast" true)

;; Preventing the usage of a reference to a deleted object
;; (defn f []
;;   (let-do [x @"DATA"
;;            r &x]
;;     (delete x)
;;     (IO.println r)))

;; Same as above, but deleting the argument
;; (defn g [x]
;;   (let-do [r &x]
;;     (delete (the String x))
;;     (IO.println r)))

;; A function that takes refs as arguments
;; (defn h [r]
;;   (IO.println r))

;; Using 'nth' : (Fn [(Ref (Array a) q) Int] (Ref a q))
;; (defn n []
;;   (let [xs [@"A" @"B" @"C"]
;;         xsref &xs
;;         r (Array.nth xsref 0)]
;;     (do
;; ;;      (Array.delete xs)
;;       (IO.println r))))

(macro-log "")
(macro-log "--------------------------------------------------------------------------------------------------")
(macro-log "")

;; (defn o []
;;   (let [b [1 2 3]
;;         r &b]
;;     @r))

;; (defn p []
;;   (let [b [@"DATA"]
;;         r &b
;;         n (Array.nth r 0)]
;;     @n))

;; ;; More 'nth'
;; (defn m []
;;   (let [b [@"MORE" @"DATA"]
;;         n (Array.nth &b 0)]
;;     @n))

;; Lambdas
;; (defn l []
;;   (let [x @"DATA"
;;         r &x
;;         f (fn [] (IO.println r))]
;;     (do
;;       (String.delete x)
;;       (f))))

;; (defn from-ptr [a]
;;   (if (null? a)
;;     (Maybe.Nothing)
;;     (Maybe.Just @(Pointer.to-ref a))))


;; (defn w []
;;   (let [a [1 2 3]
;;         r &a]
;;     (do
;;       ;;(Array.delete a)
;;       (IO.println &(str
;;                     (Array.nth
;;                      r
;;                      0))))))

;; (defn pair-eq [p1 p2]
;;   (and (= (Pair.a p1) (Pair.a p2))
;;        (= (Pair.b p1) (Pair.b p2)))
;;   )
