(defmodule StaticArray

  ;; NOTE: Following function declarations are copy of the ones in Array
  ;; could we share inmplementation between Array and StaticArray?
  (defndynamic foreach-internal [var xs expr]
    (let [xsym (gensym-with 'xs)
          len (gensym-with 'len)
          i (gensym-with 'i)]
      (list 'let [xsym xs
                  len (list 'StaticArray.length xsym)]
            (list 'for [i 0 len]
                  (list 'let [var (list 'StaticArray.unsafe-nth xsym i)]
                        expr)))))

  (defmacro foreach [binding expr]
    (StaticArray.foreach-internal (car binding) (cadr binding) expr))

  (doc map! "Maps a function over the static array `xs`, mutating it in place. The difference to Array.endo-map (which does the same thing internally) is that this function takes a ref (since you can never have static arrays as values) and that it returns ().")
  (defn map! [xs f]
    (for [i 0 (StaticArray.length xs)]
      (StaticArray.aset! xs i (~f (StaticArray.unsafe-nth xs i)))))

  (defn reduce [f x xs]
    (let [total x]
      (do
        (for [i 0 (StaticArray.length xs)]
          (set! total (~f total (StaticArray.unsafe-nth xs i))))
        total)))

  (doc = "compares two static arrays.")
  (defn = [a b]
    (if (/= (StaticArray.length a) (StaticArray.length b))
      false
      (let-do [eq true]
        (for [i 0 (StaticArray.length a)]
          (when (/= (StaticArray.unsafe-nth a i) (StaticArray.unsafe-nth b i))
            (do
              (set! eq false)
              (break))))
        eq)))

  (doc empty? "checks whether the array `a` is empty.")
  (defn empty? [a]
    (= (StaticArray.length a) 0))

  (doc any? "checks whether any of the elements in `a` match the function `f`.")
  (defn any? [f a]
    (let-do [res false]
      (for [i 0 (length a)]
        (when (~f (unsafe-nth a i))
          (do
            (set! res true)
            (break))))
      res))

  (doc all? "checks whether all of the elements in `a` match the function `f`.")
  (defn all? [f a]
    (let-do [res true]
      (for [i 0 (length a)]
        (when (not (~f (unsafe-nth a i)))
          (do
            (set! res false)
            (break))))
      res))

  (doc find "finds an element in `a` that matches the function `f` and wraps it in a `Just`.

If it doesn’t find an element, `Nothing` will be returned.")
  (defn find [f a]
    (let-do [res (Maybe.Nothing)]
      (for [i 0 (length a)]
        (when (~f (unsafe-nth a i))
          (do
            (set! res (Maybe.Just @(unsafe-nth a i)))
            (break))))
      res))

  (doc find-index "finds the index of the first element in `a` that matches the function `f` and wraps it in a `Just`.

If it doesn’t find an index, `Nothing` will be returned.")
  (defn find-index [f a]
    (let-do [ret (Maybe.Nothing)]
      (for [i 0 (length a)]
        (when (~f (unsafe-nth a i))
          (do
            (set! ret (Maybe.Just i))
            (break))))
      ret))

  (doc unsafe-first "takes the first element of an array.

Generates a runtime error if the array is empty.")
  (defn unsafe-first [a]
    @(unsafe-nth a 0))

  (doc first "takes the first element of an array and returns a `Just`.

Returns `Nothing` if the array is empty.")
  (defn first [a]
    (if (empty? a)
      (Maybe.Nothing)
      (Maybe.Just @(unsafe-nth a 0))))

  (doc unsafe-last "takes the last element of an array.

Generates a runtime error if the array is empty.")
  (defn unsafe-last [a]
    @(unsafe-nth a (Int.dec (length a))))


  (doc last "takes the last element of an array and returns a `Just`.

Returns `Nothing` if the array is empty.")
  (defn last [a]
    (if (empty? a)
      (Maybe.Nothing)
      (Maybe.Just @(unsafe-nth a (Int.dec (length a)))))))
